name: Docker CI build docker images and push

on:
  push:
    branches: [dev, main]
    paths:
      - 'frontend/**'
      - 'backend1/**' 
      - 'backend2/**'
      - '.github/workflows/**'
  pull_request:
    branches: [dev, main]
    types: [opened, synchronize, reopened]
    paths:
      - 'frontend/**'
      - 'backend1/**'
      - 'backend2/**'
      - '.github/workflows/**'

jobs:
  # Centralized version management to avoid conflicts
  versioning:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && (needs.changes.outputs.frontend == 'true' || needs.changes.outputs.backend == 'true')
    needs: changes
    runs-on: v1
    outputs:
      new_version: ${{ steps.get-version.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version
        id: get-version
        run: |
          git fetch --tags
          latest_version=$(git tag --sort=-version:refname | head -n 1)
          
          if [ -z "$latest_version" ]; then
            echo "Using default version 1.0.0 because no tags were found"
            new_version="1.0.0"
          else
            commits=$(git log ${latest_version}..HEAD --oneline)
            
            if echo "$commits" | grep -q -E "(BREAKING CHANGE|!:|feat!:|fix!:)"; then
              new_version=$(semver bump major "$latest_version")
            elif echo "$commits" | grep -q -E "^[a-f0-9]+ feat:"; then
              new_version=$(semver bump minor "$latest_version")
            else
              new_version=$(semver bump patch "$latest_version")
            fi
          fi
          
          # Check if tag already exists
          if git tag -l | grep -q "^$new_version$" || git ls-remote --tags origin | grep -q "refs/tags/$new_version"; then
            echo "Tag $new_version already exists. Using existing version."
          else
            echo "Creating new tag: $new_version"
            git tag "$new_version"
            if ! git push origin "$new_version" 2>/dev/null; then
              echo "Failed to push tag (might already exist). Continuing with existing version."
            fi
          fi
          
          echo "new_version=$new_version" >> $GITHUB_OUTPUT
          echo "Using version: $new_version"

  changes:
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.changes.outputs.frontend }}
      backend: ${{ steps.changes.outputs.backend }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            frontend:
              - 'frontend/**'
            backend:
              - 'backend1/**'
              - 'backend2/**'


  build-frontend:
    if: github.event_name == 'push' && needs.changes.outputs.frontend == 'true'
    needs: [changes, versioning]
    runs-on: v1  # frontend runner
    environment: ${{ github.ref_name == 'main' && 'production' || 'development' }}
    outputs:
      new_version: ${{ needs.versioning.outputs.new_version || steps.dev-version.outputs.new_version }}

    steps:
      - uses: actions/checkout@v4

      - name: DockerHub Login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_UNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWD }}

      - name: Get development version
        id: dev-version
        if: github.ref_name != 'main'
        run: |
          new_version="${{ github.ref_name }}-${{ github.sha }}"
          echo "new_version=$new_version" >> $GITHUB_OUTPUT
          echo "Using development version: $new_version"

      - name: Set final version
        id: final-version
        run: |
          if [ "${{ github.ref_name }}" == "main" ]; then
            version="${{ needs.versioning.outputs.new_version }}"
          else
            version="${{ steps.dev-version.outputs.new_version }}"
          fi
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "Final version: $version"
        
      - name: Cache Frontend Build
        id: cache-frontend-build
        uses: actions/cache@v4
        with:
          path: frontend/node_modules
          key: ${{ runner.os }}-frontend-dep-${{ hashFiles('frontend/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-frontend-dep

      - name: Build Frontend App
        env:
          VITE_APP_VERSION: ${{ steps.final-version.outputs.version }}
          VITE_CLERK_PUBLISHABLE_KEY: ${{ vars.VITE_CLERK_PUBLISHABLE_KEY }}
          VITE_URL_ADDR: ${{ vars.VITE_URL_ADDR }}
          VITE_BASE_PATH: /blog-app-fellowship/
        run: |
          yarn --cwd frontend install --network-timeout 600000 
          yarn add @types/node
          yarn --cwd frontend build 

      - name: Upload Frontend Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ steps.final-version.outputs.version }}
          path: frontend/dist/

      - name: Build and Push Frontend
        run: |
          docker build \
            --build-arg VITE_CLERK_PUBLISHABLE_KEY=${{ vars.VITE_CLERK_PUBLISHABLE_KEY }} \
            --build-arg VITE_URL_ADDR=${{ vars.VITE_URL_ADDR }} \
            -f ./frontend/frontend.Dockerfile \
            -t safalkarki/frontend:${{ steps.final-version.outputs.version }} ./frontend

          n=0
          until [ $n -ge 5 ]; do
            docker push safalkarki/frontend:${{ steps.final-version.outputs.version }} && break
            n=$((n+1))
            echo "Push failed, retrying ($n)..."
            sleep 5
          done

      - name: Export Frontend Docker Image
        run: |
          mkdir -p docker-exports
          docker save safalkarki/frontend:${{ steps.final-version.outputs.version }} -o docker-exports/frontend-${{ steps.final-version.outputs.version }}.tar
      
      - name: Copy Docker image export to frontend dist folder
        run: |
          mkdir -p frontend/dist/docker-images
          cp docker-exports/frontend-${{ steps.final-version.outputs.version }}.tar frontend/dist/docker-images/

      - name: Upload Frontend Docker Image Export
        uses: actions/upload-artifact@v4
        with:
          name: frontend-docker-image-${{ steps.final-version.outputs.version }}
          path: docker-exports/frontend-${{ steps.final-version.outputs.version }}.tar

  build-backends:
    if: github.event_name == 'push' && needs.changes.outputs.backend == 'true'
    needs: [changes, versioning]
    runs-on: v2   # backend runner
    environment: ${{ github.ref_name == 'main' && 'production' || 'development' }}
    outputs:
      new_version: ${{ needs.versioning.outputs.new_version }}

    steps:
      - uses: actions/checkout@v3

      - name: DockerHub Login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_UNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWD }}

      - name: Set version from versioning job
        id: set-version
        run: |
          echo "Using version from versioning job: ${{ needs.versioning.outputs.new_version }}"
          echo "new_version=${{ needs.versioning.outputs.new_version }}" >> $GITHUB_OUTPUT
      
      - name: Cache Backend Build
        id: cache-backend-build
        uses: actions/cache@v4
        with: 
          path: |
            backend1/node_modules
            backend2/node_modules
          key: ${{ runner.os }}-backend-dep-${{ hashFiles('backend1/yarn.lock', 'backend2/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-backend-dep

      - name: Build Backend App
        run: |
          yarn --cwd backend1 install --network-timeout 600000
          yarn --cwd backend1 build
          yarn --cwd backend2 install --network-timeout 600000
          yarn --cwd backend2 build

      - name: Upload Backend Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-build-${{ needs.versioning.outputs.new_version }}
          path: |
            backend1/dist/
            backend2/dist/

      - name: Build and Push Backend1
        # if: steps.cache-backend-build.outputs.cache-hit != 'true'
        run: |
          docker build -f ./backend1/backend1.Dockerfile -t safalkarki/backend1:${{ needs.versioning.outputs.new_version }} ./backend1
          n=0
          until [ $n -ge 5 ]; do
            docker push safalkarki/backend1:${{ needs.versioning.outputs.new_version }} && break
            n=$((n+1))
            echo "Push failed, retrying ($n)..."
            sleep 5
          done

      - name: Build and Push Backend2
        run: |
          docker build -f ./backend2/backend2.Dockerfile -t safalkarki/backend2:${{ needs.versioning.outputs.new_version }} ./backend2
          n=0
          until [ $n -ge 5 ]; do
            docker push safalkarki/backend2:${{ needs.versioning.outputs.new_version }} && break
            n=$((n+1))
            echo "Push failed, retrying ($n)..."
            sleep 5
          done

      - name: Export Backend Docker Images
        run: |
          mkdir -p docker-exports
          docker save safalkarki/backend1:${{ needs.versioning.outputs.new_version }} -o docker-exports/backend1-${{ needs.versioning.outputs.new_version }}.tar
          docker save safalkarki/backend2:${{ needs.versioning.outputs.new_version }} -o docker-exports/backend2-${{ needs.versioning.outputs.new_version }}.tar

      - name: Copy Backend Docker image export to frontend dist folder
        run: |
          mkdir -p frontend/dist/docker-images
          cp docker-exports/backend1-${{ needs.versioning.outputs.new_version }}.tar frontend/dist/docker-images/
          cp docker-exports/backend2-${{ needs.versioning.outputs.new_version }}.tar frontend/dist/docker-images/

      - name: Upload Backend Docker Image Exports
        uses: actions/upload-artifact@v4
        with:
          name: backend-docker-images-${{ needs.versioning.outputs.new_version }}
          path: docker-exports/

  pr-checks:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Conventional Commit Check
        uses: wagoid/commitlint-github-action@v5

      - name: Check for sensitive data in env files
        run: |
          echo "Checking for exposed secrets in .env files..."
          if grep -r "sk_test_\|pk_test_\|sk_live_\|pk_live_" --include="*.env" . 2>/dev/null | grep -v "placeholder\|example\|your_key_here"; then
            echo "Found potential exposed secrets in .env files"
            exit 1
          else
            echo "No exposed secrets found"
          fi

      - name: Dockerfile existence check
        run: |
          echo "Checking if required Dockerfiles exist..."
          missing_files=0
          
          if [[ ! -f "./frontend/frontend.Dockerfile" ]]; then
            echo "frontend/frontend.Dockerfile not found"
            missing_files=1
          fi
          
          if [[ ! -f "./backend1/backend1.Dockerfile" ]]; then
            echo "backend1/backend1.Dockerfile not found"
            missing_files=1
          fi
          
          if [[ ! -f "./backend2/backend2.Dockerfile" ]]; then
            echo "backend2/backend2.Dockerfile not found"
            missing_files=1
          fi
          
          if [ $missing_files -eq 1 ]; then
            exit 1
          fi
          
          echo "All required Dockerfiles found"

  deploy:
    needs: [build-frontend, build-backends]
    if: github.ref_name == 'dev' || github.ref_name == 'main'
    runs-on: v1
    steps:
      - uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          password: ${{ secrets.SSH_PASSWORD }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            docker stop $(docker container ps -q)
            docker container prune -f

            echo "Starting postgres.."
            
            docker rm -f postgres >/dev/null 2>&1 || true
            docker network inspect my-backend-network >/dev/null 2>&1 || docker network create my-backend-network

            docker run -d --rm --init \
            --name postgres \
            --network my-backend-network \
            -e POSTGRES_USER=${{ secrets.POSTGRES_USER }} \
            -e POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }} \
            -e POSTGRES_DB=${{ secrets.POSTGRES_DB }} \
            -v pgdata:/var/lib/postgresql/data \
            -p 5432:5432 \
            postgres:latest

            echo "Deploying to server..."

            docker stop frontend backend1 backend2 2>/dev/null || true
            docker rm frontend backend1 backend2 2>/dev/null || true

            echo "Frontend version: ${{ needs.build-frontend.outputs.new_version }}"
            echo "Backend1 version: ${{ needs.build-backends.outputs.new_version }}"
            echo "Backend2 version: ${{ needs.build-backends.outputs.new_version }}"

            docker pull safalkarki/frontend:${{ needs.build-frontend.outputs.new_version }}
            docker pull safalkarki/backend1:${{ needs.build-backends.outputs.new_version }}
            docker pull safalkarki/backend2:${{ needs.build-backends.outputs.new_version }}

            docker run -d --name frontend -p 80:80 safalkarki/frontend:${{ needs.build-frontend.outputs.new_version }}
            docker run -d --name backend1 -p 3000:3000 \
            --network my-backend-network \
            -e PORT=${{ vars.BACKEND1_PORT }} \
            -e DB_PORT=${{ vars.DB_PORT }} \
            -e DB_HOST=${{ vars.DB_HOST }} \
            -e DB_USER=${{ secrets.BACKEND1_DB_USER }} \
            -e DB_PASSWORD=${{ secrets.BACKEND1_DB_PASSWORD }} \
            -e DB_NAME=${{ vars.DB_NAME }} \
            -e DB_CLIENT=${{ vars.DB_CLIENT }} \
            -e NODE_ENV=${{ vars.NODE_ENV }} \
            -e CLERK_PUBLISHABLE_KEY=${{ secrets.BACKEND1_CLERK_PUBLISHABLE_KEY }} \
            -e CLERK_SECRET_KEY=${{ secrets.BACKEND1_CLERK_SECRET_KEY }} \
            safalkarki/backend1:${{ needs.build-backends.outputs.new_version }} 


            docker run -d --name backend2 -p 3001:3001 \
            --network my-backend-network \
            -e PORT=${{ vars.BACKEND2_PORT }} \
            -e DB_PORT=${{ vars.DB_PORT }} \
            -e DB_HOST=${{ vars.DB_HOST }} \
            -e DB_USER=${{ secrets.BACKEND2_DB_USER }} \
            -e DB_PASSWORD=${{ secrets.BACKEND2_DB_PASSWORD }} \
            -e DB_NAME=${{ vars.DB_NAME }} \
            -e DB_CLIENT=${{ vars.DB_CLIENT }} \
            -e NODE_ENV=${{ vars.NODE_ENV }} \
            -e CLERK_PUBLISHABLE_KEY=${{ secrets.BACKEND2_CLERK_PUBLISHABLE_KEY }} \
            -e CLERK_SECRET_KEY=${{ secrets.BACKEND2_CLERK_SECRET_KEY }} \
            safalkarki/backend2:${{ needs.build-backends.outputs.new_version }}

            echo "Deployment completed successfully"

  create-release:
      needs: [build-frontend, build-backends]
      if: github.ref_name == 'main'
      runs-on: ubuntu-latest
      steps:
        - name: Download frontend artifact
          uses: actions/download-artifact@v4
          with:
            name: frontend-docker-image-${{ needs.build-frontend.outputs.new_version }}
            path: docker-artifacts/frontend

        - name: Download backend artifacts
          uses: actions/download-artifact@v4
          with:
            name: backend-docker-images-${{ needs.build-backends.outputs.new_version }}
            path: docker-artifacts/backend

        - name: Create GitHub Release
          uses: softprops/action-gh-release@v1
          with:
            tag_name: ${{ needs.build-frontend.outputs.new_version }}
            name: Release ${{ needs.build-frontend.outputs.new_version }}
            draft: false
            prerelease: false
            files: |
              docker-artifacts/frontend/*.tar
              docker-artifacts/backend/*.tar
          env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy-frontend-pages:
    if: github.ref_name == 'main'
    needs: build-frontend
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-${{ needs.build-frontend.outputs.new_version }}
          path: dist

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: dist

  trivy-scan:
    if: github.ref_name == 'main'
    needs: [build-frontend, build-backends]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: DockerHub Login for scanning
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_UNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWD }}

      - name: Pull Docker images for scanning
        run: |
          echo "Pulling images for security scanning..."
          docker pull safalkarki/frontend:${{ needs.build-frontend.outputs.new_version }}
          docker pull safalkarki/backend1:${{ needs.build-backends.outputs.new_version }}
          docker pull safalkarki/backend2:${{ needs.build-backends.outputs.new_version }}

      - name: Download Trivy HTML template
        run: |
          mkdir -p contrib
          wget -O contrib/html.tpl https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/html.tpl

      - name: Run Trivy vulnerability scanner on Frontend image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'safalkarki/frontend:${{ needs.build-frontend.outputs.new_version }}'
          format: 'template'
          template: '@contrib/html.tpl'
          output: 'frontend-scan.html'

      - name: Run Trivy vulnerability scanner on Backend1 image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'safalkarki/backend1:${{ needs.build-backends.outputs.new_version }}'
          format: 'template'
          template: '@contrib/html.tpl'
          output: 'backend1-scan.html'

      - name: Run Trivy vulnerability scanner on Backend2 image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'safalkarki/backend2:${{ needs.build-backends.outputs.new_version }}'
          format: 'template'
          template: '@contrib/html.tpl'
          output: 'backend2-scan.html'

      - name: Move scan reports to directory
        run: |
          mkdir -p scan-reports
          mv frontend-scan.html scan-reports/
          mv backend1-scan.html scan-reports/
          mv backend2-scan.html scan-reports/

      - name: Upload scan reports artifact
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-reports-${{ needs.build-frontend.outputs.new_version }}
          path: scan-reports/

  semgrep-scan:
    if: github.ref_name == 'main' && (needs.build-frontend.result == 'success' || needs.build-backends.result == 'success')
    needs: [changes, build-frontend, build-backends]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed files
        id: changed-files
        run: |
          # Get list of changed files
          if [ "${{ needs.changes.outputs.frontend }}" == "true" ] && [ "${{ needs.changes.outputs.backend }}" == "true" ]; then
            echo "Both frontend and backend changed, scanning all"
            echo "scan_paths=frontend/ backend1/ backend2/" >> $GITHUB_OUTPUT
          elif [ "${{ needs.changes.outputs.frontend }}" == "true" ]; then
            echo "Only frontend changed, scanning frontend"
            echo "scan_paths=frontend/" >> $GITHUB_OUTPUT
          elif [ "${{ needs.changes.outputs.backend }}" == "true" ]; then
            echo "Only backend changed, scanning backends"
            echo "scan_paths=backend1/ backend2/" >> $GITHUB_OUTPUT
          else
            echo "No relevant changes detected"
            echo "scan_paths=" >> $GITHUB_OUTPUT
          fi

      - name: Run Semgrep scan on changed files
        if: steps.changed-files.outputs.scan_paths != ''
        run: |
          python -m pip install semgrep
          
          # Create output directory
          mkdir -p scan-reports
          
          # Scan only the changed paths
          echo "Scanning paths: ${{ steps.changed-files.outputs.scan_paths }}"
          
          # Run semgrep with both text and JSON output
          semgrep scan ${{ steps.changed-files.outputs.scan_paths }} \
            --text --text-output=scan-reports/semgrep.txt \
            --json --json-output=scan-reports/semgrep.json \
            --config=auto || true
          
          # Generate HTML report from JSON
          python3 << 'EOF'
          import json
          import html
          from datetime import datetime
          
          try:
              with open('scan-reports/semgrep.json', 'r') as f:
                  data = json.load(f)
          except:
              data = {"results": []}
          
          html_content = f"""
          <!DOCTYPE html>
          <html>
          <head>
              <title>Semgrep Security Scan Report</title>
              <style>
                  body {{ font-family: Arial, sans-serif; margin: 20px; }}
                  .header {{ background-color: #f8f9fa; padding: 20px; border-radius: 5px; margin-bottom: 20px; }}
                  .summary {{ background-color: #e7f3ff; padding: 15px; border-radius: 5px; margin-bottom: 20px; }}
                  .finding {{ background-color: #fff; border: 1px solid #ddd; padding: 15px; margin-bottom: 10px; border-radius: 5px; }}
                  .severity-high {{ border-left: 5px solid #dc3545; }}
                  .severity-medium {{ border-left: 5px solid #fd7e14; }}
                  .severity-low {{ border-left: 5px solid #ffc107; }}
                  .severity-info {{ border-left: 5px solid #17a2b8; }}
                  .code {{ background-color: #f8f9fa; padding: 10px; border-radius: 3px; font-family: monospace; white-space: pre-wrap; }}
                  .metadata {{ color: #6c757d; font-size: 0.9em; }}
              </style>
          </head>
          <body>
              <div class="header">
                  <h1>Semgrep Security Scan Report</h1>
                  <p><strong>Scan Date:</strong> {datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")}</p>
                  <p><strong>Scanned Paths:</strong> ${{ steps.changed-files.outputs.scan_paths }}</p>
              </div>
              
              <div class="summary">
                  <h2>Summary</h2>
                  <p><strong>Total Findings:</strong> {len(data.get('results', []))}</p>
              </div>
          """
          
          if data.get('results'):
              html_content += "<h2>Findings</h2>"
              for i, result in enumerate(data['results'], 1):
                  severity = result.get('extra', {}).get('severity', 'info').lower()
                  message = html.escape(result.get('extra', {}).get('message', 'No message'))
                  path = html.escape(result.get('path', 'Unknown'))
                  rule_id = html.escape(result.get('check_id', 'Unknown'))
                  
                  html_content += f"""
                  <div class="finding severity-{severity}">
                      <h3>Finding #{i}: {rule_id}</h3>
                      <p><strong>Severity:</strong> <span style="text-transform: uppercase;">{severity}</span></p>
                      <p><strong>File:</strong> {path}</p>
                      <p><strong>Line:</strong> {result.get('start', {}).get('line', 'Unknown')}</p>
                      <p><strong>Message:</strong> {message}</p>
                  </div>
                  """
          else:
              html_content += """
              <div class="summary">
                  <h2>No Security Issues Found</h2>
                  <p>Semgrep scan completed successfully with no security findings in the changed files.</p>
              </div>
              """
          
          html_content += """
              <div class="metadata">
                  <hr>
                  <p><em>Generated by Semgrep Security Scanner</em></p>
              </div>
          </body>
          </html>
          """
          
          with open('scan-reports/semgrep.html', 'w') as f:
              f.write(html_content)
          
          print("HTML report generated successfully")
          EOF

      - name: Upload Semgrep scan results
        if: steps.changed-files.outputs.scan_paths != ''
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-scan-results-${{ needs.build-frontend.outputs.new_version || needs.build-backends.outputs.new_version }}
          path: scan-reports/



  deploy-scan-reports:
    if: github.ref_name == 'main' && (needs.trivy-scan.result == 'success' || needs.semgrep-scan.result == 'success')
    needs: [build-frontend, build-backends, trivy-scan, semgrep-scan]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create scan reports directory
        run: mkdir -p scan-reports

      - name: Download Trivy scan reports
        if: needs.trivy-scan.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: security-scan-reports-${{ needs.build-frontend.outputs.new_version || needs.build-backends.outputs.new_version }}
          path: scan-reports/trivy
        continue-on-error: true

      - name: Download Semgrep scan reports
        if: needs.semgrep-scan.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: semgrep-scan-results-${{ needs.build-frontend.outputs.new_version || needs.build-backends.outputs.new_version }}
          path: scan-reports/semgrep
        continue-on-error: true

      - name: Generate index page
        run: |
          cat > scan-reports/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
              <title>Security Scan Reports</title>
              <style>
                  body { font-family: Arial, sans-serif; margin: 40px; }
                  .header { background-color: #f8f9fa; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
                  .scan-section { background-color: #fff; border: 1px solid #ddd; padding: 20px; margin-bottom: 20px; border-radius: 5px; }
                  .btn { display: inline-block; padding: 10px 20px; background-color: #007bff; color: white; text-decoration: none; border-radius: 3px; margin-right: 10px; }
                  .btn:hover { background-color: #0056b3; }
                  .trivy-btn { background-color: #28a745; }
                  .semgrep-btn { background-color: #17a2b8; }
                  .timestamp { color: #6c757d; font-size: 0.9em; }
              </style>
          </head>
          <body>
              <div class="header">
                  <h1>Security Scan Reports</h1>
                  <p class="timestamp">Generated: $(date -u)</p>
                  <p>Automated security scanning results for the blog-app-fellowship project</p>
              </div>
              
              <div class="scan-section">
                  <h2>Available Scan Reports</h2>
                  <p>Click the links below to view detailed security scan reports:</p>
                  
                  <h3>Trivy Vulnerability Scans</h3>
                  <p>Container image vulnerability scanning results:</p>
                  <a href="trivy/frontend-scan.html" class="btn trivy-btn">Frontend Image Scan</a>
                  <a href="trivy/backend1-scan.html" class="btn trivy-btn">Backend1 Image Scan</a>
                  <a href="trivy/backend2-scan.html" class="btn trivy-btn">Backend2 Image Scan</a>
                  
                  <h3>Semgrep Code Analysis</h3>
                  <p>Static code analysis for security vulnerabilities:</p>
                  <a href="semgrep/semgrep.html" class="btn semgrep-btn">Code Security Scan</a>
                  <a href="semgrep/semgrep.txt" class="btn semgrep-btn">Raw Text Report</a>
                  <a href="semgrep/semgrep.json" class="btn semgrep-btn">JSON Report</a>
              </div>
              
              <div class="scan-section">
                  <h2 About These Scans</h2>
                  <ul>
                      <li><strong>Trivy:</strong> Scans Docker images for known vulnerabilities in OS packages and dependencies</li>
                      <li><strong>Semgrep:</strong> Performs static analysis to find security vulnerabilities in source code</li>
                  </ul>
                  <p><em>These scans run automatically on every push to the main branch.</em></p>
              </div>
          </body>
          </html>
          EOF

      - name: Deploy scan reports to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: scan-reports
          destination_dir: scan
          keep_files: true  